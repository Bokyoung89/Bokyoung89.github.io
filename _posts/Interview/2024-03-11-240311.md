---
published: false
title: "[TIL] 기술 인터뷰 Q&A 7일차"
categories: 
- Interview
tag:
- Java
- Spring
---
> 👩🏻‍💻 기술면접을 대비하여 학습한 내용을 TIL로 기록한다.

* 3/7일에 학습한 내용이나 팀 면접을 보고 난 뒤 부족한 답변을 보완했다.

### 기술면접 예상 질문
**1. Java Map의 내부 구현은 어떻게 이루어져 있을지 추측해보실 수 있을까요?**

_키워드 : key-value, 순서 유지 x, 키-중복x 값-중복o, HashMap, TreeMap, 해싱, 레드-블랙-트리, 정렬_

* Map은 키(key)와 값(value)을 하나의 쌍으로 묶어서 저장하는 자료구조입니다. 순서를 유지되지 않으며 키는 중복을 허용하지 않고 값은 중복을 허용한다는 특징이 있습니다.
* 구현클래스 중 HashMap은 해싱 기법으로 데이터를 저장합니다. 내부적으로는 저장할 데이터의 키를 해시 함수함수를 통해 해시코드 즉 index로 변환합니다. index에 해당하는 bucket값을 찾으면 선택된 bucket에 키-값 쌍을 저장하게 됩니다.
* TreeMap은 내부적으로 레드-블랙 트리(Red-Black Tree)를 사용하여 데이터를 저장하고 관리합니다. 부모 키값과 비교해서 키값이 낮은 것은 왼쪽 자식 노드에 키 값이 높은 것은 오른쪽 자식 노드에 배치하므로 key값을 기준으로 오름차순으로 순서가 정렬되어 있다는 특징이 있습니다.
* TreeMap은 데이터를 저장할 때 즉시 정렬하기에 추가나 삭제가 HashMap보다 오래 걸립니다. 따라서 대부분의 경우는 HashMap을 사용하는 것이 좋고, 다만 정렬이나 정렬된 데이터를 조회해야 하는 범위 검색이 필요하는 경우에는 treeMap이 더 효율적일 수 있습니다.

**추가 질문 : 해싱에 대해 추가적으로 설명해주세요.**
* 해시함수를 이용하여 데이터를 해시테이블에 저장하고 검색하는 기법을 말합니다. 해시함수는 데이터가 저장된 곳을 알려주기 때문에 다량의 데이터 중에서도 원하는 데이터를 빠르게 찾을 수 있습니다. 
* 해싱의 자료구조는 배열과 링크드 리스트의 조합으로 되어있는데, 링크드 리스트의 특성상 리스트의 크기가 커질수록 검색속도가 떨어지게 됩니다. 따라서 키의 수는 많지만 각 키마다 데이터는 하나만 저장되는 경우에 빠른 검색 결과를 얻을 수 있습니다.

**추가 질문 : HashMap과 TreeMap의 시간복잡도는 어떻게 되나요?**
* HashMap은 삽입, 삭제, 갱신, 검색이 상수 시간에 처리되므로 O(1)의 시간복잡도를 가집니다. 
* TreeMap의 경우 정렬이 사용되기 때문에 데이터의 크기에 비례하므로 O(log N)의 시간복잡도를 가집니다.

**추가 질문 : List, Set, Map을 비교하고, 어떤 경우에 쓰면 적합한지도 설명해주세요.**
* List는 순서가 있고 데이터의 중복을 허용합니다. 따라서 대기자 명단을 구현할 때 적합합니다. 
* Set은 순서가 유지되지 않고 데이터의 중복도 허용하지 않습니다. 
* Map은 키와 값의 쌍으로 이우러진 데이터의 집합으로 순서는 유지되지 않고 키는 중복을 허용하지 않고 값은 중복을 허용합니다. 앞자리가 같은 우편번호나 지역번호에 사용할 수 있습니다.

---

**2. DI와 IoC에 대해 아는 만큼 설명해주실 수 있을까요?**

_키워드 : 의존성 주입, 컨테이너, 객체 지향, 위임, 결합_

* IoC와 DI는 밀접하게 연관된 개념입니다. IoC는 객체의 제어 흐름을 역전시켜 객체의 생성 및 관리를 외부에서 담당하는 것을 말하며 DI는 이러한 IoC를 구현하는 방법 중 하나입니다.
* IoC는 제어의 역전이라고 하며, 기존의 제어 흐름이 개발자에게 있던 것을 외부 컨테이너 또는 프레임워크에 위임하는 것을 말합니다. 이것은 주로 의존성 관리와 객체 생성에 적용됩니다. 이를 통해 객체 간의 결합도를 낮추고 유연성과 확장성을 향상시킵니다.
* 제어의 역전을 설명할 때 프레임워크와 라이브러리를 비교해볼 수 있을 것 같습니다. 프레임워크는 개발자가 작성한 코드의 제어 흐름을 프레임워크가 제어하고 실행합니다.  이에 반해 라이브러리를 사용하는 것은 개발자가 직접 코드를 작성하고 제어의 흐름까지 담당한다고 볼 수 있습니다.
* DI는 의존성 주입으로서 객체가 필요로 하는 의존성을 외부에서 주입하여 객체 간의 결합도를 낮추는 디자인 패턴입니다. 따라서 객체 간의 의존성 관리를 외부에 위임하여 제어의 역전을 이룹니다.

**추가질문 : 스프링 프레임 워크에서 DI와 IoC 개념이 사용되는 예시를 설명해주세요.**
* 스프링에서는 객체 간의 의존성 주입을 위해 어노테이션을 사용합니다. @Autowired 어노테이션은 스프링에게 해당 필드를 자동으로 주입하도록 지시합니다. 따라서 UserService가 UserRepository에 의존하면서도 직접 생성하지 않고, 스프링이 DI를 통해 주입합니다.

**추가질문 : 프레임 워크에서 어떤 과정으로 DI가 진행될까요?**
* 빈(Bean) 설정: 먼저, 애플리케이션의 구성을 정의하는 설정 파일이나 어노테이션을 작성합니다. 이러한 설정에는 의존성 관리를 위해 필요한 빈들의 정의가 포함됩니다.
* 빈 등록: 설정 파일이나 어노테이션을 통해 정의된 빈들은 스프링 컨테이너에 등록됩니다. 이 과정에서 스프링은 빈의 메타데이터를 읽고, 빈의 생성 및 관리를 수행할 준비를 합니다.
* 의존성 확인: 빈들이 등록된 후에는 각 빈의 의존성을 확인합니다. 이를 위해 스프링은 빈의 속성, 생성자 인수 또는 설정 정보를 분석하여 빈이 필요로 하는 다른 빈들을 식별합니다.
* 의존성 해결: 의존성이 확인된 빈들은 스프링 컨테이너에 의해 필요한 빈들로 주입됩니다. 이 과정에서 스프링은 설정에 따라 의존성을 주입하는 방법을 결정합니다. 일반적으로 생성자 주입, 속성 주입 또는 메서드 주입을 사용합니다.
* 빈의 초기화: 모든 의존성이 주입된 후에는 빈의 초기화 작업이 수행됩니다. 이 단계에서는 빈이 필요한 모든 설정을 마치고, 애플리케이션에서 사용할 준비가 완료됩니다.
* 애플리케이션 실행: 모든 빈들이 준비되고 초기화되면, 스프링 애플리케이션은 실행됩니다. 각 빈은 자신의 역할을 수행하고, 필요한 서비스를 제공합니다.

**추가질문 : 스프링 프레임 워크에서 그럼 장점뿐만이 아니라 단점도 있을까요?**
* DI와 loC는 개발을 편하고 빠르게 해준다는 장점이 있지만 내부 동작 과정이 복잡하여 이를 제대로 이해하지 않은 상태에서 사용하면 오히려 문제가 생겼을 때 원인을 파악하는 것에 시간이 걸릴 수 있을 것 같습니다. 따라서 사용하기 전에 왜 필요한지를 먼저 정확히 이해하고 원리를 아는 과정이 중요하다고 생각합니다.

---

**3. MVC 모델이란 무엇인지 설명해주실 수 있을까요?**
* MVC는 Model-View-Controller의 약자로, 소프트웨어 디자인 패턴 중 하나입니다. 애플리케이션의 구성 요소들을 세 가지 역할로 나누어 관리합니다.
* 모델(Model): 데이터와 비즈니스 로직을 담당합니다. 데이터의 구조를 정의하고 데이터를 조작하며, 데이터의 유효성 검사와 비즈니스 규칙을 정의합니다.
* 뷰(View): 사용자에게 데이터를 표시하는 역할을 합니다. 사용자에게 정보를 표시하고 사용자 입력을 받아 컨트롤러로 전달합니다.
* 컨트롤러(Controller): 모델과 뷰 간의 중개자 역할을 합니다. 사용자의 요청을 받아 모델에 데이터를 요청합니다. 그리고 모델에서 받은 데이터를 적절한 뷰로 전달하여 사용자에게 제공합니다.

**추가 질문 : MVC를 사용했을 때 이점은 무엇인가요?**
* 분리된 역할: MVC는 각 구성 요소가 서로 독립적으로 작동하므로, 코드를 유지 보수하고 확장하기 쉽습니다. 각 부분을 개별적으로 수정할 수 있기 때문에 한 부분의 변경이 다른 부분에 미치는 영향을 최소화할 수 있습니다.
* 재사용성: 뷰와 컨트롤러는 모델과 분리되어 있으므로 여러 뷰와 컨트롤러를 동일한 모델과 연결하여 재사용할 수 있습니다. 이는 코드의 재사용성을 높이고 개발 시간을 단축시킵니다.
* 유연성: MVC는 각 구성 요소의 독립성을 보장하기 때문에, 사용자 인터페이스의 변경 또는 비즈니스 로직의 수정과 같은 요구 사항 변화에 대응하기가 용이합니다.
* 테스트 용이성: 각각의 구성 요소를 단위 테스트하기가 쉽습니다. 모델, 뷰, 컨트롤러는 서로 독립적으로 테스트할 수 있으며, 통합 테스트를 통해 전체 어플리케이션을 테스트할 수도 있습니다.

**추가 질문 : 소프트웨어 디자인 패턴은 왜 필요하다고 생각하나요?**
* 디자인 패턴은 협업과 관계가 깊다고 생각합니다. 프로그래머들이 의사소통을 할 때 모두 디자인 패턴을 알고 있다면 프로그래밍 구조에 대해 장황하게 설명할 필요 없이 간단한 단어로도 의사소통이 가능합니다. 따라서 협업이 중요한 개발 분야에서 디자인 패턴은 중요한 개념이라고 생각합니다.

**추가 질문 : MVC 외에 알고 있는 디자인 패턴이 있나요?**
* MVVM은 MVC의 변형으로, 주로 GUI 애플리케이션 개발에 사용됩니다. MVC와 유사하지만, View와 Model 사이에 ViewModel이라는 새로운 구성 요소가 추가됩니다.
* MVP는 MVC와 유사한 패턴으로, 주로 GUI 애플리케이션 개발에 사용됩니다. MVC와 다르게 Presenter가 Controller의 역할을 수행합니다.


_항해 개발자 취업 리부트 코스를 수강하고 작성한 콘텐츠 입니다._