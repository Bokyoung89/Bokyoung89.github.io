---
published: false
title: "[TIL] 기술 인터뷰 Q&A 5일차"
categories: 
- Interview
tag:
- Java
- Spring
---
> 👩🏻‍💻 기술면접을 대비하여 학습한 내용을 TIL로 기록한다.

### 기술면접 예상 질문
**1. Annotation이란 무엇이고 구체적으로 어떤 것이 있는지 예시를 들어 설명해주실 수 있을까요?**

**자바에서 Annotation이란?**
* 자바에서 사용되는 Annotaion은 코드에 메타데이터를 추가하는 방법으로서 컴파일러에게 코드를 컴파일하거나 실행할 때 추가적인 정보를 제공합니다. 
비즈니스 로직에 영향을 주지 않지만 해당 타켓의 연결방법이나 소스코드 구조를 변경할 수 있습니다. 이 속성을 어떤 용도로 사용할까? 이 클래스에 어떤 역할을 줄까?를 결정해서 붙여준다고 볼 수 있습니다.

**Annotaion의 종류**
* 자바에 내장된 어노테이션은 자바 코드에 적용되는 어노테이션과 다른 어노테이션에 적용되는 메타 어노테이션으로 나뉩니다.

**자바 코드에 적용되는 어노테이션**
* 자바 코드에 적용되는 어노테이션은 @Depulicated, @Override, @SuppresWarings, @SafeVarargs, @FunctionalInterface가 있습니다.
* @Deprecated은 표시된 요소가 더 이상 사용 되지 않으며 더 이상 사용되어서는 안 됨을 나타냅니다. 컴파일러는 프로그램이 주석과 함께 메서드, 클래스 또는 필드를 사용할 때마다 경고를 생성합니다
* @Override은 해당 요소가 부모 클래에 선언된 요소를 재정의해야 함을 컴파일러에 알립니다.
* @SuppressWarnings는 컴파일러가 발생시키는 특정 경고를 무시하도록 지시합니다.
* @SafeVarargs은 가변 인자 메서드를 사용할 때 ClassCastException 등의 안전하지 않은 형변환 경고를 컴파일 시점에 무시하도록 지시합니다.
* @FunctionalInterface는 해당 인터페이스가 함수형 인터페이스임을 나타냅니다.

**메타 어노테이션**
* 메타 어노테이션에는 @Retention, @Target, @Documented, @Inherited, @Repeatable이 있습니다.
* @Retention는 표시된 주석이 저장되는 방법을 지정합니다.
* @Target은 어노테이션을 적용할 수 있는 대상 유형을 지정합니다.
* @Documented는 해당 어노테이션이 Javadoc으로 문서화될 것임을 나타냅니다.
* @Inherited는 어노테이션이 부모 클래스에서 상속될 수 있음을 나타냅니다.
* @Repeatable은 어노테이션을 여러 번 적용될 수 있음을 나타냅니다.
* 이러한 메타 어노테이션들을 사용하여 라이브러리나 프레임워크에서 제공하는 어노테이션의 동작을 제어할 수 있습니다.

---

**2.Spring Security의 구조와 JWT 발급 과정에 대해 설명해주실 수 있을까요?**

**Spring security의 처리 과정**
* Spring security는 인증과 권한에 대한 부분을 filter 흐름에 따라 처리합니다. 기본적으로 인증 절차를 거친 후에 인가 절차를 진행하며 인가 과정에서 해당 리소스에 대한 접근 권한이 있는지 확인을 하게 됩니다.

**Spring Security의 구조**
* Authentication (인증): 사용자가 시스템에 로그인할 때 인증이 수행됩니다. AuthenticationManager 인터페이스는 실제 인증을 수행하는데 사용되며, AuthenticationProvider 구현체가 실제 인증 로직을 구현합니다. UserDetailsService는 사용자의 신원을 확인하기 위해 사용자 정보를 제공하는 인터페이스입니다.
* Authorization (인가): 인증된 사용자가 특정 권한을 가지고 있는지 확인합니다. AccessDecisionManager를 사용하여 인가를 수행합니다.
* filter Chain (필터 체인): Spring Security는 FilterChainProxy를 사용하여 보안 필터 체인을 구성합니다. 이 필터 체인은 HTTP 요청을 처리하고, 인증 및 인가를 수행합니다. 각 필터는 특정한 보안 작업을 수행하며, 예를 들어 사용자의 인증 여부를 확인하고, CSRF 공격을 방지하는 등의 작업을 수행할 수 있습니다.
* Security Context (보안 컨텍스트): 보안 컨텍스트에는 현재 사용자의 인증 정보와 권한 정보 등이 포함됩니다. 이 컨텍스트는 SecurityContextHolder를 통해 접근할 수 있습니다.

**Spring Security에 JWT 토큰을 적용했을 때 발급 과정**
1. 사용자 로그인: 사용자는 로그인을 시도합니다. 사용자가 제공한 정보를 바탕으로 DB에서 회원이 존재하는지 확인합니다.
2. 사용자 인증 : Spring security에서 사용자를 인증합니다. passwordEncoder가 사용자가 제공한 비밀번호의 일치 여부를 확인합니다.
3. JWT 생성 : 서버는 사용자 인증이 성공적으로 완료되면 JWT 토큰을 생성합니다. JWT 토큰에는 사용자의 고유 식별자, 클레임, 토큰 발급 및 만료 시간, 권한이 포함됩니다.
4. JWT 서명 : 생성된 토큰에 서명을 추가합니다. secret key와 payload를 서명 알고리즘에 입력해 서명을 만듭니다.  그 정보는 헤더에 기록해둡니다. 알고리즘이 적힌 헤더, payload, 서명을 base64로 인코딩하고 각 정보는 .으로 연결되어 JWT로 만들어집니다. 이 정보를 브라우저(클라이언트)에 전달합니다.
5. 클라이언트 응답 : 클라이언트는 JWT를 쿠키나 로컬 스토리지같은 브라우저의 저장 시스템에 보관합니다.
6. 클라이언트 요청 : 사용자가 인증이 필요한 엔드포인트에 요청을 보내면 클라이언트는 JWT를 Authorization 헤더나 쿼리 매개변수로 서버 전송합니다. 서버는 JWT를 base64로 디코딩합니다. 그리고 브라우저가 전달한 header와 payload 그리고 자신이 가지고 있는 secret키로 서명을 해봅니다. 그 서명이 브라우저에서 전달한 서명과 일치하면 인증에 성공하고 사용자가 원하는 작업을 처리해줍니다.

**쿠키 기반의 세션 방식**
* 우선 로그인을 시도합니다. 서버는 DB에서 회원이 존재하는지를 확인합니다. 존재한다면 sesstion table에 어떤 사용자가 로그인을 했는지와 임시 비밀번호를 발급했다고 기록합니다. sesstion id를 반환하면 웹 서버가 쿠키값으로 응답합니다. 정보는 브라우저에 저장되고 다음에 접속할 때마다 서버에 전송됩니다. 
* 이때 세션 방식의 단점은 사용자의 이름과 같은 개인 정보가 필요하면 서버에 조회를 다시 해야한다는 점입니다. sesstion id에는 사용자의 정보가 없기 때문입니다. 
* 권한이 필요한 작업을 서버에 요청하면  sesstion id가 전송됩니다. 웹서버는 DB에 sesstion id 여부를 조회해서 회원이 있는지 확인합니다. 존재한다면 요청한 작업을 처리해줍니다. 
* 여기서 또 발생하는 단점은 서버에 접속 때마다 session 테이블 확인해야하고, 사용자가 새로운 기기에서 접속할 때마다 session id가 다시 생겨야 하기 때문에 session table의 데이터가 엄청나게 증가한다는 점입니다.

**JWT 방식의 장점**
* JWT는 메시지를 담을 수 있기 때문에 애플리케이션이 자주 필요한 정보를 payload에 담아두기 좋습니다. 이 정보를 가져오기 위해 DB에 다시 접속하지 않아도 되므로 서버에 부담을 줄일 수 있습니다. JWT를 사용하면 로그인 할 때 한번만 db에 접속하고 이후 확인 과정에서는 db에 접속할 필요가 없습니다.

**JWT의 구성요소**
* payload : payload에는 클레임(claim)이라고 불리는 데이터가 포함됩니다. 클레임은 토큰에 대한 정보를 나타냅니다.
* signature : header와 payload를 인코딩한 후, secret key를 사용해 서명한 값입니다.  이 서명은 header와 payload가 변조되지 않았음을 증명하는 역할을 합니다.
* header : 어떤 알고리즘으로 디지털 서명을 했는지를 기록해둡니다. 헤더에는 JWT로 고정된 토큰의 타입과 사용된 해싱 알고리즘이 포함됩니다.

**3. N+1 문제의 발생 이유와 해결 방법에 대해 설명해주실 수 있을까요? 해결 방법은 3가지 이상 말씀해주시면 좋습니다.**

**N+1 문제란?**
* ORM을 사용할 때 연관 관계에서 발생하는 이슈로 연관 관계가 설정된 엔티티를 조회할 경우에 조회된 데이터 갯수(n) 만큼 연관관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어오게 되는 문제입니다.

**예로 설명하면**
* User와 Post 두 개의 테이블이 있습니다. 각 유저는 여러 개의 포스트를 작성할 수 있습니다. 이를 ORM을 사용하여 모델화했다고 가정해 봅시다. 이제 특정 유저가 작성한 포스트를 가져와야 한다고 가정해 봅시다. 
* 특정 유저의 포스트를 가져오는 것처럼 보이지만, 실제로는 두 개의 데이터베이스 쿼리를 실행합니다. 첫 번째는 User 모델에서 특정 유저를 가져오고, 그 다음에 해당 유저의 포스트를 가져오기 위해 Post 모델에서 추가적인 쿼리를 실행합니다. 이런 상황에서 "N+1 문제"가 발생합니다. 
* N은 유저의 수를 나타내며, 이 경우에는 1입니다. 따라서 N+1은 1+1, 즉 총 2개의 쿼리를 의미합니다. 만약 데이터베이스에 수백 개 이상의 유저가 있고, 각 유저마다 여러 개의 포스트가 있다면, 이러한 방식으로 쿼리를 실행하면 데이터베이스에 부하가 걸리고 응답 시간이 길어질 수 있습니다.  
* 따라서 N+1 문제를 해결하기 위해서는 데이터를 한 번의 쿼리로 효율적으로 가져오는 방법을 사용해야 합니다.

**N+1 문제 해결 방법**
1. Join Fetch 
* Join Fetch는 연관된 엔티티를 함께 로드하여 한 번의 쿼리로 데이터를 가져옵니다. 이를 통해 N+1 문제를 해결할 수 있습니다. Hibernate의 @ManyToOne 및 @OneToMany 관계에 대해 JOIN FETCH 를 사용할 수 있습니다.
* 주의할 점: Join Fetch를 남용하면 데이터를 불필요하게 로드하여 성능 문제를 야기할 수 있습니다. 불필요한 조인이 발생하여 쿼리의 복잡성이 증가할 수 있습니다.
2. @EntityGraph 
* EntityGraph는 연관된 엔티티를 로드할 때 사용되는 특정 그래프를 정의합니다. Hibernate JPA에서는 @NamedEntityGraph 어노테이션을 사용하여 정의하고, javax.persistence.EntityGraph를 사용하여 쿼리 메소드에 적용할 수 있습니다.
* 주의할 점: EntityGraph를 사용하면 특정 상황에 대한 로딩 전략을 명시적으로 정의할 수 있습니다. 그러나 EntityGraph를 잘못 사용하면 쿼리의 결과가 의도하지 않은 대로 반환될 수 있습니다.
3. FetchMode.SUBSELECT 
* FetchMode.SUBSELECT는 지연 로딩 된 컬렉션을 초기화 할 때 서브 쿼리를 사용하여 모든 데이터를 한 번에 가져옵니다. 
* 주의할 점 : SUBSELECT를 사용하면 N+1 문제를 해결할 수 있지만, 컬렉션의 크기에 따라 성능에 영향을 미칠 수 있습니다. 대규모 데이터셋에 대해 사용할 때 성능 이슈를 유발할 수 있습니다.
4. BatchSize
* BatchSize를 사용하면 지정된 크기의 일괄 처리 작업을 통해 데이터를 로드합니다.
* 주의할 점 : BatchSize를 적절하게 조정하면 일괄 처리 작업을 통해 성능을 향상시킬 수 있습니다. 그러나 너무 작거나 큰 BatchSize를 사용하면 성능에 영향을 줄 수 있습니다. 최적의 BatchSize는 데이터 모델 및 환경에 따라 다를 수 있습니다.

---
**참고 아티클**
* [[SpringBoot] Spring Security란?](https://mangkyu.tistory.com/76)
* [생활코딩 - JWT](https://youtu.be/36lpDzQzVXs?si=W2fw2OtiZzxImxbT)

_항해 개발자 취업 리부트 코스를 수강하고 작성한 콘텐츠 입니다._