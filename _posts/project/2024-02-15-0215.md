---
published: true
title: "[트러블 슈팅] 마이크로서비스에서 인증 프로세스 구현"
categories:
- pre-order-service
tag:
- pre-order-service

toc: true
toc_label: "목록" 
toc_icon: "bars"
toc_sticky: true

---
> 👩🏻‍💻 마이크로서비스에서 인증을 구현한 과정을 기록하였습니다.

## 마이크로서비스 전환과 인증 프로세스 고민

모놀리식 서비스를 마이크로서비스로 모듈화하면서 각 모듈이 가져야 할 기능 외에 모든 로직을 제거하였다. 각 모듈간의 관계를 분리하면서 user-service에서 담당했던 인증/인가를 사용할 수 없게 되었다. 해당 시스템은 로그인 이후 모든 API 호출에 대해서는 토큰을 검증하고 있다.

### AS-IS 기존 모놀리식 예약 구매 서비스의 인증 절차

1. 클라이언트에서 api 요청이 들어오면 user-service의 JwtTokenFilter가 JWT 토큰의 유효성을 검사한다.
2. 토큰 정보가 유효한 경우, DB에서 얻은 사용자 정보를 가지고 인증 정보(authentication)를 설정한다.
3. 호출된 메서드는 authentication를 가지고 필요한 작업을 수행한다.

**PostService**

```java
// 게시물을 생성하는 컨트롤러 메서드
// 사용자가 인증되면 인증 정보인 authentication를 전달받는다.
@PostMapping
public Response<Void> create(@RequestBody PostCreateReqeust reqeust, Authentication authentication) {
        // 인증된 사용자의 이름을 얻어와 메서드에 전달한다.
        postService.create(reqeust.getTitle(), reqeust.getContent(), authentication.getName());
        return Response.success();
        }
```

**JwtTokenFilter**

```java
@Slf4j
@RequiredArgsConstructor
public class JwtTokenFilter extends OncePerRequestFilter {
    
    private final String key;
    private final UserService userService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        
        final String header = request.getHeader(HttpHeaders.AUTHORIZATION);

        if (header == null || !header.startsWith("Bearer ")) {
            log.error("Error occurs while getting header. header is null or invalid");
            filterChain.doFilter(request, response);
            return;
        }

        try {
            final String token = header.split(" ")[1].trim();

            // JWT 토큰의 유효성을 검사한다.
            if (JwtTokenUtils.isExpired(token, key)) {
                log.error("Key is expired");
                filterChain.doFilter(request, response);
                return;
            };

            // 토큰에서 사용자 이메일을 추출한다.
            String email = JwtTokenUtils.getEmail(token, key);
            // 추출한 이메일을 사용하여 데이터베이스에서 해당 사용자 정보를 조회한다.
            UserAccount userAccount = userService.loadByUserByEmail(email);

            // 사용자 정보로부터 Spring Security의 인증 토큰을 생성한다.
            UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                    userAccount, null, null
            );
            // 요청에 대한 인증 정보를 설정한다.
            authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
            SecurityContextHolder.getContext().setAuthentication(authentication);
        } catch (RuntimeException e) {
            log.error("Error occurs while validating : {}", e.toString());
            filterChain.doFilter(request, response);
            return;
        }
        
        filterChain.doFilter(request, response);
    }
}
```

## user-serivce의 역할 분리

우선 인증/인가를 계속 `user-service`에게 위임할 것인가를 고민했다. `user-serivce`는 회원가입, 로그인, 프로필 조회, 수정 기능만을 주기로 결정했기에 인증은 당연히 `user-service`의 역할이 되어선 안됐다. 그렇다면 마이크로서비스 구조에서 인증/인가를 구현하는 방법은 무엇일까?

내 프로젝트의 경우 모든 서비스의 요청은 인증 절차를 거쳐야 했기에 서비스 최전방에 위치한 API Gateway를 통해 인증 절차를 위임하는 것이 가장 적합하다고 판단하였다. 하지만 내가 암호화한 Bcrypt 알고리즘은 단방향 hash이기 때문에 복호화가 불가능한 문제가 있었다.

jwt.io 사이트를 통해 디코딩이 가능한 것을 확인했고, spring cloud gateway의 customfilter를 구현해 회원가입/로그인 이후에 발생하는 모든 API 호출은 인증을 거치도록 하였다. user-service는 회원가입도 로그인 시 토큰 발급 기능만 남겨두었다. 결과적으로는 의도한대로 서비스 간의 역할을 분리할 수 있었다.

### TO-BE 마이크로서비스 예약 구매 서비스의 인증 절차

1. 포스트 작성 API를 요청한다. Header에 토큰 정보를 담고 있다.
2. Gateway에서 토큰의 유효성 검사를 진행한다.
3. 토큰이 유효하면 API가 정상적으로 호출되고 이후 기능을 진행한다.

---

### reference
[https://medium.com/spoontech/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B5%AC%EC%A1%B0-msa-%EC%9D%98-%EC%9D%B8%EC%A6%9D-%EB%B0%8F-%EC%9D%B8%EA%B0%80-authorization-authentication-a595179ab88e](https://medium.com/spoontech/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B5%AC%EC%A1%B0-msa-%EC%9D%98-%EC%9D%B8%EC%A6%9D-%EB%B0%8F-%EC%9D%B8%EA%B0%80-authorization-authentication-a595179ab88e)