---
published: true
title: "[TIL] 기술 인터뷰 Q&A 3일차"
categories: 
- TIL
tag:
- Java
- Spring
---
> 👩🏻‍💻 기술면접을 대비하여 학습한 내용을 TIL로 기록한다.

### 기술면접 예상 질문
**1. JVM의 스택과 힙메모리 영역에 대해 아는 만큼 설명해주실 수 있을까요?**
* 스택과 힙은 JVM에서 메모리 관리를 효율적으로 수행하기 위해 나누어진 주요 메모리 영역입니다.
* 스택은 각각의 스레드마다 개별적으로 할당되며 메소드 호출과 관련된 지역 변수, 메소드 호출 정보 등을 저장합니다. 메소드가 호출될때마다 해당 메소드에 대한 스택 프레임이 생성되며 메소드 실행이 완료되면 해당 스택 프레임이 스택에서 제거됩니다. 스택은 크기가 제한돼 있고 스택 오버플로우가 발생할 수 있습니다.
* 힙은 객체 인스턴스가 생성되는 곳으로 동적으로 할당된 메모리를 관리합니다. 클래스의 인스턴스, 배열 등이 저장됩니다. 개발자가 직접 힙 메모리를 제거하지 않고 JVM의 가비지 컬렉터가 더이상 참조되지 않는 변수들은 수거해 메모리를 수거합니다.  힙은 모든 스레드에서 공유되는 자원이며 프로그램이 실행되는동안 계속해서 존재합니다.

**2. 클래스와 인스턴스의 차이에 대해 설명해주실 수 있을까요?**
* 클래스는 객체를 생성하기 위한 일종의 설계도 또는 틀입니다. 클래스는 데이터와 메서드로 구성되며 이를 통해 객체의 상태와 행동을 정의합니다. 예를 들어 자동차 클래스는 자동차 객체가 가져야 하는 색상, 모델명과 주행, 정지 등 행동을 정의하는데 사용됩니다.
* 인스턴스틑 클래스의 설계에 따라 실제 메모리에 할당된 실체화된 객체를 말합니다. 각각 고유한 상태를 가지며 클래스에서 정의된 메서드를 실행할 수 있습니다. 예로 자동차 클래스에서 생성된 실제 자동차 객체가 해당 클래스의 인스턴스입니다.

**3. Garbage Collector의 역할, 원리, 알고리즘에 대해 아는 만큼 설명해주실 수 있을까요?**

**가비지 컬렉터란?**
* 가비지 컬렉터는 프로그래머가 명시적으로 메모리를 할당하고 해제하는 작업을 하지 않아도 더이상 사용되지 않는 객체들의 메모리를 자동으로 회수하는 역할을 하는 프로그램 컴포넌트입니다. 
주로 Java와 같은 프로그래밍 언어에서 메모리 관리를 지원하여 메모리 누수를 방지합니다.

**가비지 컬렉터의 대상**
* 가비지 컬렉터는 더 이상 참조되지 않는 객체를 찾기 위해 도달 가능성을 판단합니다. 예를 들어 JVM 메모리에서 객체들은 실질적으로 heap 영역에서 생성되고, 메서드 영역이나 스택 영역에서는 객체의 주소만 참조합니다.
이렇게 생성된 힙 영역의 객체들이 메서드가 끝나는 특정 이벤트로 인해 힙 영역 객체의 메모리 주소를 가지고 있는 참조변수가 삭제되는 현상이 발생하면 도달하지 않은 객체들이 생깁니다.
이러한 객체들이 가비지 컬렉션의 대상이 됩니다.

**가비지 컬렉터 청소 방식**
* 가비지 컬렉터는 Mark And Sweep 방식으로 가비지를 청소합니다. 도달 가능한 객체를 표시(mark)하고, 표시되지 않은 객체를 메모리에서 해제(sweep)합니다.

**가비지 컬렉터 동작 과정**
* JVM의 힙 영역은 Young 영역과 Old 영역으로 나뉘며, 대부분의 객체는 일회성이며 짧은 생명 주기를 가진다는 전제로 설계되었습니다.
이에 따라 Young 영역에는 주로 짧은 생명 주기를 가진 객체가 할당되고, Old 영역에는 긴 생명 주기를 가진 객체가 할당됩니다.
* Young 영역은 Eden 영역과 두 개의 Survivor 영역으로 나뉘며, 객체의 생존 기간에 따라 세분화된 공간으로 가비지 컬렉션을 더욱 효율적으로 수행한다. 
Minor GC는 Young 영역에서 발생하고, Major GC는 Old 영역에서 발생한다. 
* Major GC는 일반적으로 Minor GC보다 오래 걸리며, Stop-The-World 문제를 유발할 수 있습니다. 따라서 이 시간을 최소화시키는 것이 중요하며 성능을 최적화하기 위해 다양한 가비지 컬렉션 알고리즘이 존재합니다.

**가비지 컬렉터 알고리즘**
1. Serial GC : 단일 스레드에서 작동하기 때문에 GC 작업 중에 모든 애플리케이션 스레드를 일시중지시켜 stop-the-world 시간이 가장 긴 알고리즘입니다. 작은 규모의 애플리케이션 또는 단일 사용자 시스템에 적합합니다.
2. Parallel GC : Java 8의 디폴트 GC이며 Serial GC와 기본적인 알고리즘은 같지만, Young 영역의 Minor GC를 멀티 쓰레드로 수행합니다. Serial GC에 비해 stop-the-world 시간이 감소합니다. 중간 규모의 다중 스레드 애플리케이션에 적합합니다.
3. Parallel Old GC : Parallel GC를 개선한 버전으로 Young 영역 뿐만 아니라, Old 영역에서도 멀티 쓰레드로 GC를 수행합니다. 
4. CMS GC : GC 작업을 최대한 애플리케이션 스레드와 병렬로 실행하려고 시도합니다. GC 대상을 파악하는 과정이 복잡한 여러단계로 수행되기 때문에 다른 GC 대비 CPU 사용량이 높습니다.
Java9 버젼부터 deprecated 되었고 결국 Java14에서는 사용이 중지되었습니다. 대규모 다중 스레드 애플리케이션에서 짧은 GC 일시 중지 시간이 요구되는 경우에 적합합니다.
5. G1 GC : 기존의 GC 알고리즘에서는 Heap 영역을 물리적으로 고정된 Young / Old 영역으로 나누어 사용하였지만, G1 GC는 Region이라는 영역으로 체스같이 분할하여 상황에 따라 Eden, Survivor, Old 등 역할을 고정이 아닌 동적으로 부여합니다. 
Garbage로 가득찬 영역을 빠르게 회수하여 빈 공간을 확보하므로, 결국 GC 빈도가 줄어드는 효과를 얻게 되는 원리입니다.
CMS GC를 대체하기 위해 jdk 7 버전에서 최초로 release된 GC이고, Java 9+ 버전의 디폴트 GC로 지정되었습니다. 대규모 애플리케이션에서 예측 가능한 GC 일시 중지 시간을 요구하는 경우에 적합합니다.
6. Shenandoah GC : 기존 CMS가 가진 단편화, G1이 가진 pause의 이슈를 해결하기 위해 고안된 알고리즘입니다. 강력한 Concurrency와 가벼운 GC 로직으로 heap 사이즈에 영향을 받지 않고 일정한 pause 시간이 소요가 특징입니다.
Java 12에 release되었습니다.
7. ZGC (Z Garbage Collector) : 대량의 메모리(8MB ~ 16TB)를 low-latency로 잘 처리하기 위해 디자인 된 GC입니다. ZGC가 내세우는 최대 장점 중 하나는 힙 크기가 증가하더도 'stop-the-world'의 시간이 절대 10ms를 넘지 않는다는 것입니다.
Java 15에 release 되었습니다.

_항해 개발자 취업 리부트 코스를 수강하고 작성한 콘텐츠 입니다._