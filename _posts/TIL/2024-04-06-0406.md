---
published: true
title: "[TIL] 기술면접 대비 21일차"
categories: 
- TIL
tag:
- MSA
- Garbage Collector

toc: true
toc_label: "목록"
toc_icon: "bars"
toc_sticky: true

---
> 👩🏻‍💻 기술면접을 대비하여 학습한 내용을 TIL로 기록한다.

## 기술 예상 질문
### 1. MSA란 무엇이며 어떤 점에서 MSA가 해당 프로젝트에 적합하다고 생각하셨나요?
* MSA는 하나의 애플리케이션을 여러 개의 작고 독립적인 서비스들로 구성하는 설계 방식입니다. 
서비스가 독립적이므로 배포가 빠르고 장애 전파도 방지할 수 있어 규모가 큰 프로젝트에서 안정성 있는 서비스를 유지할 수 있습니다.
또한 서비스마다 적합한 기술을 선택할 수 있어 기술 자유도가 높고, 개발자가 서비스를 나누어 관리할 수 있기 때문에 관리 부담도 줄일 수 있습니다.
물론 단점도 있는데, 서비스가 API 호출을 하는 과정에서 비용과 시간이 들고, 장애 추적이나 디버깅도 모놀리식에 비해 까다롭습니다.
DB도 분리되면서 트랜잭션 관리도 까다롭습니다.
* 해당 프로젝트는 대규모 트래픽을 대비해 안정적으로 운영하는 서비스를 만드는 것이 목표였기 때문에 MSA가 적합하다고 생각했습니다.
다른 서비스에 비해 트래픽이 몰릴 것으로 예상되는 재고관리, 상품, 주문 서비스는 트래픽에 대비해 설계되어야 합니다. 서비스를 분리하여 개발함으로서 트래픽 처리에 적합한 기술을 선택해 사용할 수 있습니다.
또한 다른 서비스에 영향을 주지 않아야 장애를 줄일 수 있기 때문에 MSA 설계로 장애 전파를 방지할 수 있다는 점도 고려하였습니다.

**1-1. 추가질문 : 하나의 서비스에만 트래픽이 몰릴 경우는 어떻게 하나요?**

[//]: # (일반적으로는 스케일 아웃으로 트래픽을 분산시키는 방법이 있습니다.)

[//]: # (MSA 환경에서 다른 서비스를 호출할 때, 서버에 과부하. 실패 X Circuit Breaker, Retry 사용 장애난 서비스 호출 차단 / 미리 설정한 응답값 사용.)

[//]: # (특정 기능 결제. 요청 실패 → 사용자 경험 떨어뜨리는 것.  kafaka 메시지 브로커.)

### 2. Garbage Collector에 대해서 설명해주세요.
* Garbage Collector는 JVM 내에서 메모리 관리를 담당하는 시스템입니다. Garbage Collector의 주요 역할은 프로그램이 실행되는 동안 더이상 사용되지 않는 동적인 메모리 영역을 식별하고 해제하는 것입니다. 이를 통해 메모리 누수를 방지할 수 있습니다.
Garbage Collector가 실행되는 힙 영역은 객체의 생존 기간에 따라 Young 영역과 Old 영역으로 나뉩니다. 서로 다른 메모리 구조를 가지고 있기 때문에 세부적인 동작 방식은 다르지만 공통적으로 Stop The World와 Mark and Sweep 두 단계를 따릅니다.
Garbage Collector가 실행되면 먼저 Stop The World를 통해 애플리케이션의 모든 작업이 중단됩니다. 그 다음 Garbage Collector는 Mark and Sweep 과정을 통해 사용되는 메모리와 사용되지 않는 메모리를 식별하고 Mark되지 않은 객체들은 메모리를 해제합니다.
Young 영역은 주로 짧은 생명 주기를 가진 객체가 할당되기 때문에 실행 시간이 빨라 Minor GC가 실행되도 애플리케이션에 큰 영향을 주지 않습니다. 반면 Old 영역은 긴 생명 주기를 가진 객체가 할당되므로 Major GC가 오래 걸려 자연히 Stop The World에 의한 애플리케이션 지연 시간도 늘어납니다.
따라서 지연 시간을 최소화하는 것이 중요하며 성능을 최적화하기 위한 다양한 GC 알고리즘이 존재합니다.

**2-1. 추가질문 : Garbage Collector 알고리즘에 대해 알고 있나요?**

* **Serial GC**는 단일 스레드에서 작동하기 때문에 GC 작업 중에 모든 애플리케이션 스레드를 일시중지시켜 stop-the-world 시간이 가장 긴 알고리즘입니다. 작은 규모의 애플리케이션 또는 단일 사용자 시스템에 적합합니다.
* **Parallel GC**는 Java 8의 디폴트 GC이며 Serial GC와 기본적인 알고리즘은 같지만, Young 영역의 Minor GC를 멀티 쓰레드로 수행합니다. Serial GC에 비해 stop-the-world 시간이 감소합니다. 중간 규모의 다중 스레드 애플리케이션에 적합합니다.
* **Parallel Old GC**는 Parallel GC를 개선한 버전으로 Young 영역 뿐만 아니라, Old 영역에서도 멀티 쓰레드로 GC를 수행합니다.
* **CMS GC**는 GC 작업을 최대한 애플리케이션 스레드와 병렬로 실행하려고 시도합니다. GC 대상을 파악하는 과정이 복잡한 여러 단계로 수행되기 때문에 다른 GC 대비 CPU 사용량이 높습니다. Java9 버젼부터 deprecated 되었고 결국 Java14에서는 사용이 중지되었습니다. 대규모 다중 스레드 애플리케이션에서 짧은 GC 일시 중지 시간이 요구되는 경우에 적합합니다.
* **G1 GC**는 CMS GC를 대체하기 위해 jdk 7 버전에서 최초로 release된 GC이고, Java 9+ 버전의 디폴트 GC로 지정되었습니다.  기존의 GC 알고리즘에서는 Heap 영역을 물리적으로 고정된 Young / Old 영역으로 나누어 사용하였지만, G1 GC는 Region이라는 영역으로 체스같이 분할하여 상황에 따라 Eden, Survivor, Old 등 역할을 고정이 아닌 동적으로 부여합니다. 즉, 가비지가 많은 Region에 대해 우선적으로 GC를 수행하여 빈 공간을 빠르게 확보하고, 결국 GC 빈도가 줄어드는 효과를 얻게 됩니다.
* **Shenandoah GC**는 기존 CMS가 가진 단편화, G1이 가진 pause의 이슈를 해결하기 위해 고안된 알고리즘입니다. 강력한 Concurrency와 가벼운 GC 로직으로 heap 사이즈에 영향을 받지 않고 일정한 pause 시간이 소요가 특징입니다. Java 12에 release되었습니다.
* **ZGC**는 대량의 메모리(8MB ~ 16TB)를 low-latency로 잘 처리하기 위해 디자인 된 GC입니다. ZGC가 내세우는 최대 장점 중 하나는 힙 크기가 증가하더도 'stop-the-wor'의 시간이 절대 10ms를 넘지 않는다는 것입니다. Java 15에 release 되었습니다.

**2-2. 추가질문 : GC가 과도하게 일어나 Out Of Memory가 발생하게 된다면 어떤 방법을 사용해 분석할 수 있을까요?**

* 우선 Heap의 높은 사용량을 만든 주범을 알아내기 위해 Heap Dump를 사용해야 합니다. Heap Dump는 Java 힙 영역에서 사용 중인 모든 객체의 스냅샷을 포함하는 파일을 말합니다. 즉 장애가 났을 때의 Heap 상태를 기록으로 남겨 그 당시에 어떤 Java 객체들이 많이 만들어졌는지 분석해보아야 합니다. 