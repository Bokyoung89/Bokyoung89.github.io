---
title: "TIL-20-04-26"
categories: TIL
---

# 객체 지향 프로그래밍
* 레고 블럭처럼 조립해서 하나의 프로그램을 만드는 것. 
* 쉽게 말하면, 객체는 여러 목적을 가진 **로직(변수와 메소드)** 를 그룹핑한 것. 따라서 다른 곳에도 활용 가능해진다.(재활용성 ↑)

## 문법과 설계
### 설계
* 현실을 소프트웨어화 시켜서 문제를 해결하는 것.
* **추상화(abstract)** : 복잡한 현실에서 우리가 필요하는 관심사를 추출하여 단순화시키는 행위.
* 좋은 설계는 지식을 넘어 지혜의 영역이다. 일단은 지식을 익히자. 어떻게 동작하는지 충분히 이해하는 것이 우선이다.

### 부품화
* **좋은 객체를 만드는 것** = 로직을 재활용 가능하도록 부품화하는 것. 부품화에는 정답이 없고 적절한 방법을 찾아야 함.
* 메소드의 기본 취지는 연관된 로직을 결합해서 메소드라는 완제품을 만드는 것. 프로그램이 커지면서 메소드와 변수를 관리하기 어려워졌고,
그것을 도약한 것이 **객체 지향 프로그래밍**이다.
* 연관된 메소드와 그 메소드가 사용하는 변수들을 분류하고 그룹핑 즉, 부품화하는 것. 이렇게 그룹핑한 대상이 **객체**이다.

### 은닉화, 캡슐화
* 제대로된 부품이라면 그것이 어떻게 만들어졌는지 몰라도 쓸 수 있어야 함.
* 내부의 동작 방법을 단단한 케이스(객체) 안에 **숨기고** 사용자에게는 부품의 사용 방법(메소드)만을 **노출**하는 것.

### 인터페이스
* 잘 만들어진 부품은 부품과 부품을 서로 교환할 수 있어야 함. 즉, **표준화** 되어 있어야 함. 이러한 규격(연결점)을 **인터페이스**라고 함.

# 클래스와 인스턴스 그리고 객체
* 클래스는 객체를 만들기 위한 설계도, 인스턴스는 설계도에 따라 만들어진 구체적인 제품. 굳이 비유하자면 클래스는 정의, 인스턴스는 호출.
* 변수로 상징되는 데이터와 연산으로 상징되는 메소드를 어떻게 그룹핑할까? 이런 맥락에서 탄생한 개념이 객체지향 프로그래밍

## 객체화

```
class Calculator{
    int left, right;
      
    public void setOprands(int left, int right){
        this.left = left;
        this.right = right;
    }
      
    public void sum(){
        System.out.println(this.left+this.right);
    }
      
    public void avg(){
        System.out.println((this.left+this.right)/2);
    }
}
  
public class CalculatorDemo4 {
      
    public static void main(String[] args) {
          
        Calculator c1 = new Calculator();
        c1.setOprands(10, 20);
        c1.sum();       
        c1.avg();       
          
        Calculator c2 = new Calculator();
        c2.setOprands(20, 40);
        c2.sum();       
        c2.avg();
    }
  
}
```

* 객체 : 하나의 독립된 프로그램. 변수와 메소드의 집합. 프로그램 안에 있는 작은 프로그램.
* this : 구체적인 인스턴스, 클래스에서 선언된 변수를 가리킴.

### 클래스
* 위의 변수 left와 right, 메소드 sum과 avg는 계산을 하기 위해 연관된 로직이므로 Calculator라는 이름으로 그룹핑한다.
* 클래스는 연관되어 있는 변수와 메소드의 집합이다.

### 인스턴스
* new Calculator()라는 객체를 만들어서 변수 c1에 담고 인스턴스화(구체적인 객체)한다. 변수의 데이터 타입은 클래스이다.

**객체를 만든다는 것은 사용자 데이터타입을 만드는 것과 같다.**  
**객체 지향의 객체를 하나의 작은 프로그램처럼 느껴보자. 프로그램 안에 객체라는 작은 프로그램을 만드는 것이다.**
