---
published: true
title: "TIL-23-02-26"
categories: 
- TIL
tags:
- Java
---
## 추상클래스(abstract class)
### 추상클래스란?
* 클래스가 설계도라면 추상클래스는 미완성 설계도(미완성 메서드를 포함하고 있다는 의미)
* 완성된 설계도가 아니므로 인스턴스 생성은 불가하고, 새로운 클래스를 작성하는데 도움을 줄 목적으로 작성한다.
* 예를 들어 TV 제품을 구현할 때 서로 다른 설계도를 따로 그리는 것보다, 공통부분만 그린 미완성 설계도를 그려놓고 각각의 제품을 완성하는 것이 효율적이다.
```java
//추상클래스의 선언
abstract class 클래스이름 {
    ...
}
```

### 추상메서드(abstract method)
* 선언부만 작성하고 구현부는 없는 메서드
```java
/*주석을 통해 어떤 기능을 수행할 목적으로 작성하였는지 설명한다.*/
abstract 리턴타입 메서드이름();
```
* 해당 기능이 꼭 필요하지만 자손마다 다르게 구현될 것으로 예상되는 경우에 사용한다.
* 추상클래스를 상속받는 자손클래스는 오버라이딩을 통해 추상메서드를 모두 구현해야 한다.
* 추상메서드 중 일부만 구현하는 경우, 자손클래스 역시 추상클래스로 지정해야 한다.
```java
abstract class Player {     // 추상클래스
    abstract void play(int pos)     // 추상메서드
    abstract void stop();           // 추상메서드
}

class AudioPlayer extends Player {
    void play(int pos) { }      // 추상메서드를 구현
    void stop() { }             // 추상메서드를 구현
    
}

abstract class AbstractPlayer extends Player {
    void play(int pos) { }      // 추상메서드를 구현
}
```
* 메서드를 작성할 때 구현부보다 더 중요한 부분이 선언부이다.
* 메서드의 이름과 작업에 필요한 매개변수, 리턴타입을 결정하는 것만으로도 메서드의 절반 이상이 완성된 것이다.

### 추상클래스의 작성
* 여러 클래스에 공통적으로 사용될 수 있는 추상클래스를 바로 작성하거나, **기존 클래스의 공통 부분을 뽑아서 추상클래스를 만든다.**
* 아래는 공통부분인 move 메서드를 추상메서드로 구현했다. 모든 유닛은 이동할 수 있어야하므로 move 메서드가 반드시 필요하다. 따라서 자손 클래스에서 추상메서드를 반드시 구현해야하므로 자신의 클래스에 알맞게 구현이 될 것이다.

```java
/*기존 클래스 작성*/
class Marine {
    int x, y;
    void move(int x, int y) {/*지정된 위치로 이동*/}
    void stop() {/*현재 위치에 정지*/}
    void stimPark() {/*스팀팩을 사용한다.*/}
}

class Tank {
    int x, y;
    void move(int x, int y) {/*지정된 위치로 이동*/}
    void stop() {/*현재 위치에 정지*/}
    void changeMode() {/*공격모드를 변환한다.*/}
}

class DripShip {
    int x, y;
    void move(int x, int y) {/*지정된 위치로 이동*/}
    void stop() {/*현재 위치에 정지*/}
    void unload() {/*선택된 대상을 내린다.*/}
}
```

```java
/*추상클래스로 구현*/
abstract class Unit {
    abstract void move(int x, int y);
    void stop() {/*현재 위치에 정지*/}
}

class Marine extends Unit {
    void move(int x, int y) {/*지정된 위치로 이동*/}
    void stimPark() {/*스팀팩을 사용한다.*/}
}

class Tank extends Unit{
    void move(int x, int y) {/*지정된 위치로 이동*/}
    void changeMode() {/*공격모드를 변환한다.*/}
}

class DripShip extends Unit{
    void move(int x, int y) {/*지정된 위치로 이동*/}
    void unload() {/*선택된 대상을 내린다.*/}
}
```

* 클래스들 간 공통조상이 있으면 아래처럼 조상 클래스타입 배열에 자손 인스턴스를 담을 수 있다.
* 메서드는 실제 인스턴스에 구현된 것이 호출되므로, Unit 클래스의 move 메서드를 호출하면 각 자손클래스의 인스턴스 메서드가 호출된다.
```java
Unit[] group = new Unit[4];
group[0] = new Marine();
group[1] = new Tank();
group[2] = new Marine();
group[3] = new DripShip();

for(int i = 0; i <group.length; i++)
    group[i].move(100, 200);    //Unit 배열의 모든 유닛을 좌표(100, 200)의 위치로 이동한다.
```
---
## 인터페이스
### 인터페이스란?
* 일종의 추상클래스. 추상클래스보다 추상화 정도가 높다.
* 오직 추상메서드와 상수만을 가질 수 있다.
* 구현된 것은 아무것도 없고 밑그림만 그려져 있는 '기본설계도'이다.
* 미리 정해진 규칙에 맞게 구현되도록 표준을 제시하는 데 사용된다.

### 인터페이스의 작성
* 'class' 대신 'interface'를 사용한다는 것 외에 클래스 작성과 동일하다.
* 구성요소(멤버)는 추상메서드와 상수만 가능하다.
> 모든 멤버변수는 public static final이어야 하며, 이를 생략할 수 있다.
> 모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다.
```java
interface PlayingCard {
    public static final int SPACE = 4;
    final int DIAMOND = 3;      // public static final int DIAMOND = 3;  
    static int HEART = 2;       // public static final int HEART = 2;  
    int CLOVER = 1;             // public static final int CLOVER = 1; 
    
    public abstract String getCardNumber ();
    String getCardKind();       // public abstract String getCardKind();
}
```

### 인터페이스의 상속
* 인터페이스도 클래스처럼 상속이 가능하다. (클래스와 달리 다중상속 허용)
```java
interface Moveable {
    /* 지정된 위치(x,y)로 이동하는 기능의 메서드*/
    void move (int x, int y);
}

interface Attackable {
    /* 지정된 대상(u)을 공격하는 기능의 메서드*/
    void attack(Unit u);
}

interface Fightable extends Movable, Attackabe { }
```
* 인터페이스는 Object클래스와 같은 최고 조상이 없다.

### 인터페이스의 구현
* 인터페이스를 구현하는 것은 클래스를 상속받는 것과 같다.
* 다만, 'extends' 대신 'implements'를 사용한다.
```java
class 클래스이름 implements 인터페이스이름 {
    //인터페이스에 정의된 추상메서드를 구현해야한다.
}
```
* 인터페이스에 정의된 추상메서드를 완성해야 한다.
```java
class Fighter implements Fightable {
    public void move() { /*내용 생략*/ }
    public void attack() { /*내용 생략*/ }
}

interface Fightable {
    void move(int x, int y);
    void attack(Unit u);
}
```
* 상속과 구현이 동시에 가능하다.
```java
class Fighter extends Unit implements Fightable {
    public void move(int x, int y) { /*내용 생략*/ }
    public void attack(Unit u) { /*내용 생략*/ }
}
```