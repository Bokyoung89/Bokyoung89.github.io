<h1 id="06-4-메소드">06-4 메소드</h1>
<h2 id="메소드-선언">메소드 선언</h2>
<h3 id="메소드-선언부signature">메소드 선언부(signature)</h3>
<ul>
  <li>리턴타입 : 메소드가 리턴하는 결과의 타입을 표시</li>
  <li>메소드 이름 : 메소드의 기능이 드러나도록 식별자 규칙에 맞게 이름을 지음</li>
  <li>매개 변수 선언 : 메소드를 실행할 때 필요한 데이터를 받기 위한 변수를 선언</li>
  <li>메소드 실행 블록 : 실행할 코드를 작성</li>
</ul>

<h3 id="리턴타입">리턴타입</h3>
<ul>
  <li>메소드를 실행한 후의 결과값의 타입</li>
  <li>리턴값 없을 수 있으나, 있을 경우 리턴 타입에 선언부에 명시되어야 함.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void powerOn(){ ... }
double divide(int x, int y){ ... }
</code></pre></div>    </div>
  </li>
  <li>리턴값 존재 여부에 따라 호출 방법이 다름
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>powerOn();
double result = divide(10, 20);
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="메소드-이름">메소드 이름</h3>
<ul>
  <li>숫자로 시작하면 안되고 $와 _를 제외한 특수 문자 불가</li>
  <li>메소드 이름은 소문자로 작성</li>
  <li>서로 다른 단어가 혼합된 이름은 뒤이어 오는 단어 첫 글자를 대문자로 작성
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void run(){ ... }
void startEngine(){ ... }
Stirng getName(){ ... }
int[] getScores(){ ... }
</code></pre></div>    </div>
    <h3 id="매개-변수-선언">매개 변수 선언</h3>
  </li>
  <li>메소드 실행에 필요한 데이터를 외부에서 받아 저장할 목적
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>double divide(int x, int y){ ... }
</code></pre></div>    </div>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>double result = divide(10, 20);
</code></pre></div>    </div>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>byte b1 = 10;
byte b2 = 20;
double result = divide(b1, b2);
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="매개-변수-개수를-모를-경우">매개 변수 개수를 모를 경우</h3>
<ul>
  <li>매개 변수를 배열 타입으로 선언
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int sum1(int[] values){ }
</code></pre></div>    </div>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int[] values = {1, 2, 3};   // 배열 객체 생성해서
int result = sum1(values);  // 메서드 호출
int result = sum1(new int[] {1, 2, 3, 4, 5}   // 또는 호출 시 배열객체 생성
</code></pre></div>    </div>
  </li>
  <li>배열을 생성하지 않고 값의 목록만 넘겨주는 방법
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int sum2(int ... values) {  }
</code></pre></div>    </div>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int result = sum2(1, 2, 3);   //메소드 호출 시 쉼표로 나열
int result = sum2(1, 2, 3, 4, 5);
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="리턴return문">리턴(return)문</h2>
<h3 id="리턴값이-있는-메소드">리턴값이 있는 메소드</h3>
<ul>
  <li>메소드 선언에 리턴 타입이 있는 메소드는 반드시 리턴 문을 사용해서 리턴값 지정
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return 리턴값;
</code></pre></div>    </div>
  </li>
  <li>리턴문의 리턴값은 리턴 타입이거나 리턴 타입으로 변환될 수 있어야 함
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int plus(int x, int y){
      int result = x + y;
      return result;
}
</code></pre></div>    </div>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int plus(int x, int y){
      int result = (byte) (x + y);
      return result;
}
</code></pre></div>    </div>
    <h3 id="리턴값이-없는-메소드">리턴값이 없는 메소드</h3>
  </li>
  <li>void로 선언된 메소드에서 메소드 실행을 강제 종료시킬 때 return문을 사용
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void run() {			
      while(true) {
          if(gas&gt;0) {
              System.out.println("달립니다. (gas잔량:" + gas +")");
          gas -= 1;
      } else {
          System.out.println("멈춥니다. (gas잔량:" + gas + ")");
          return;		//run() 메소드 실행 종료
      }
  }
}
</code></pre></div>    </div>
  </li>
  <li>만약 while문 뒤에 실행문이 추가적으로 있을 경우, break문을 반드시 사용해야 함. return문은 즉시 메소드를 종료시키기 때문</li>
</ul>
