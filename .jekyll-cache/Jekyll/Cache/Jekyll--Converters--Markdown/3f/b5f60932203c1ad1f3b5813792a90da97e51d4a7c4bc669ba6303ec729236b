I"2<h1 id="객체-지향-프로그래밍">객체 지향 프로그래밍</h1>
<ul>
  <li>레고 블럭처럼 조립해서 하나의 프로그램을 만드는 것.</li>
  <li>쉽게 말하면, 객체는 여러 목적을 가진 <strong>로직(변수와 메소드)</strong> 를 그룹핑한 것. 따라서 다른 곳에도 활용 가능해진다.(재활용성 ↑)</li>
</ul>

<h2 id="문법과-설계">문법과 설계</h2>
<h3 id="설계">설계</h3>
<ul>
  <li>현실을 소프트웨어화 시켜서 문제를 해결하는 것.</li>
  <li><strong>추상화(abstract)</strong> : 복잡한 현실에서 우리가 필요하는 관심사를 추출하여 단순화시키는 행위.</li>
  <li>좋은 설계는 지식을 넘어 지혜의 영역이다. 일단은 지식을 익히자. 어떻게 동작하는지 충분히 이해하는 것이 우선이다.</li>
</ul>

<h3 id="부품화">부품화</h3>
<ul>
  <li><strong>좋은 객체를 만드는 것</strong> = 로직을 재활용 가능하도록 부품화하는 것. 부품화에는 정답이 없고 적절한 방법을 찾아야 함.</li>
  <li>메소드의 기본 취지는 연관된 로직을 결합해서 메소드라는 완제품을 만드는 것. 프로그램이 커지면서 메소드와 변수를 관리하기 어려워졌고,
그것을 도약한 것이 <strong>객체 지향 프로그래밍</strong>이다.</li>
  <li>연관된 메소드와 그 메소드가 사용하는 변수들을 분류하고 그룹핑 즉, 부품화하는 것. 이렇게 그룹핑한 대상이 <strong>객체</strong>이다.</li>
</ul>

<h3 id="은닉화-캡슐화">은닉화, 캡슐화</h3>
<ul>
  <li>제대로된 부품이라면 그것이 어떻게 만들어졌는지 몰라도 쓸 수 있어야 함.</li>
  <li>내부의 동작 방법을 단단한 케이스(객체) 안에 <strong>숨기고</strong> 사용자에게는 부품의 사용 방법(메소드)만을 <strong>노출</strong>하는 것.</li>
</ul>

<h3 id="인터페이스">인터페이스</h3>
<ul>
  <li>잘 만들어진 부품은 부품과 부품을 서로 교환할 수 있어야 함. 즉, <strong>표준화</strong> 되어 있어야 함. 이러한 규격(연결점)을 <strong>인터페이스</strong>라고 함.</li>
</ul>

<h1 id="클래스와-인스턴스-그리고-객체">클래스와 인스턴스 그리고 객체</h1>
<ul>
  <li>클래스는 객체를 만들기 위한 설계도, 인스턴스는 설계도에 따라 만들어진 구체적인 제품. 굳이 비유하자면 클래스는 정의, 인스턴스는 호출.</li>
  <li>변수로 상징되는 데이터와 연산으로 상징되는 메소드를 어떻게 그룹핑할까? 이런 맥락에서 탄생한 개념이 객체지향 프로그래밍</li>
</ul>

<h2 id="객체화">객체화</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Calculator{
    int left, right;
      
    public void setOprands(int left, int right){
        this.left = left;
        this.right = right;
    }
      
    public void sum(){
        System.out.println(this.left+this.right);
    }
      
    public void avg(){
        System.out.println((this.left+this.right)/2);
    }
}
  
public class CalculatorDemo4 {
      
    public static void main(String[] args) {
          
        Calculator c1 = new Calculator();
        c1.setOprands(10, 20);
        c1.sum();       
        c1.avg();       
          
        Calculator c2 = new Calculator();
        c2.setOprands(20, 40);
        c2.sum();       
        c2.avg();
    }
  
}
</code></pre></div></div>

<ul>
  <li>객체 : 하나의 독립된 프로그램. 변수와 메소드의 집합. 프로그램 안에 있는 작은 프로그램.</li>
  <li>this : 구체적인 인스턴스, 클래스에서 선언된 변수를 가리킴.</li>
</ul>

<h3 id="클래스">클래스</h3>
<ul>
  <li>위의 변수 left와 right, 메소드 sum과 avg는 계산을 하기 위해 연관된 로직이므로 Calculator라는 이름으로 그룹핑한다.</li>
  <li>클래스는 연관되어 있는 변수와 메소드의 집합이다.</li>
</ul>

<h3 id="인스턴스">인스턴스</h3>
<ul>
  <li>new Calculator()라는 객체를 만들어서 변수 c1에 담고 인스턴스화(구체적인 객체)한다. 변수의 데이터 타입은 클래스이다.</li>
</ul>

<p><strong>객체를 만든다는 것은 사용자 데이터타입을 만드는 것과 같다.</strong><br />
<strong>객체 지향의 객체를 하나의 작은 프로그램처럼 느껴보자. 프로그램 안에 객체라는 작은 프로그램을 만드는 것이다.</strong></p>

<h2 id="중첩-for문-연습--증가">중첩 for문 연습 (* 증가)</h2>
<ul>
  <li>좌측이 직각인 삼각형</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for(int i=1; i&lt;5; i++) {
	for(int j=1; j&lt;=i; j++) {
		System.out.print("*");
        	if(i == j) {
		    System.out.println();
		}
	}		
}

//결과값
*
**
***
****
</code></pre></div></div>

<ul>
  <li>우측이 직각인 삼각형</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for(int i=1; i&lt;5; i++) {
	for(int j=4; j&gt;0; j--) {
		if(i &lt; j) {
			System.out.print(" ");
		} else {
		    System.out.print("*");
		    }
		}
		System.out.println();
	    }
    }
}

//결과값
   *
  **
 ***
****
</code></pre></div></div>
:ET